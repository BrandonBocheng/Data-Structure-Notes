# 基本概念
* 空间使用  
函数PrintN，使得传入一个正整数为N的参数后，打印从1到N的全部正整数。  
```c
// 方法一：循环实现
void PrintN_1(int N)
{
    for (int i=N; i>=0; i--)
    {
        printf("%d\n", i);
    }
    return;
}
// 方法二：递归实现
void PrintN(int N)
{
    if (N)
    {
        PrintN(N - 1);
        printf("%d\n", N);
    }
    return;
}
```
* 算法效率
多项式 f(x) = a0 + a1*x^1 +... +an * x^n
```c
// 方法一
double f1(int n, double a[], double x)
{
    int i;
    double p = a[0];
    for (i = 1; i <= n; i++)
    {
        p += (a[i] * pow(x, i));
    }
    return p;
}
// 方法二
double f2(int n, double a[], double x)
{
    int i;
    double p = a[n];
    for (i = n; i > 0; i--){
        p = a[i - 1] + x * p;  // f(x) = a0+ x(a1+x(...(an-1 + x(an))...))
    }
    return p;
}
```
计时  
CLK_TCK 为常数，机器始终每秒所走的打点数 Use CLOCKS_PER_SEC instead of CLK_TCK on mac  
include <time.h>
```c
#include <stdio.h>
#include <time.h>
#include <math.h>
#define MAXN 10 // 9阶多项式的最大项数

clock_t start, stop;  //clock()返回的变量类型是 clock_t
double duration;  //秒
double f1(int n, double a[], double x);
double f2(int n, double a[], double x);

int main(int argc, char const *argv[])
{
	int i;
	double a[MAXN];
	for(i=0; i<MAXN; i++) a[i] = (double)i;  // 假定每一项系数就是i

	start = clock();
	f1(MAXN-1, a, 1.1); // 假定 x=1.1
	stop = clock();
	duration = (double)(stop -  start)/CLOCKS_PER_SEC; 
	printf("ticks1 = %f\n", (double)(stop -  start));
	printf("duration1 = %6.2e\n", duration);

	start = clock();
	f2(MAXN-1, a, 1.1); // 假定 x=1.1
	stop = clock();
	duration = (double)(stop -  start)/CLOCKS_PER_SEC;
	printf("ticks2 = %f\n", (double)(stop -  start));
	printf("duration2 = %6.2e\n", duration);  // 要占6位，小数点后2位，以e指数的形式输出

	return 0;
}

double f1(int n, double a[], double x){
    int i;
    double p = a[0];
    for (i = 1; i <= n; i++)
    {
        p += (a[i] * pow(x, i));
    }
    return p;
}

double f2(int n, double a[], double x){
    int i;
    double p = a[n];
    for (i = n; i > 0; i--){
        p = a[i - 1] + x * p;  // f(x) = a0+ x(a1+x(...(an-1 + x(an))...))
    }
    return p;
}
```
